\chapter{Bounding Volumes}
  We begin our discussion of bounding volumes by asking the following
  question: what kind of properties do we want in a bounding volume?
  Ideally, we would want the following:
  \begin{itemize}
    \item Inexpensive intersection tests.
    \item Tight fitting.
    \item Inexpensive to compute.
    \item Easy to transform (rotations are of particular importance).
    \item Use little memory.
  \end{itemize}

  Unfortunately as we will soon see, there have to be trade-offs whenever we
  select a bounding volume. For example: a sphere is trivial to test and
  occupies little memory (it only requires 4 floats). Conversely, a convex
  hull gives us a very tight bound on the object, but requires a lot more
  memory and is more expensive to test for intersections. So the choice of
  bounding volume ultimately boils down to the specific requirements of our
  application. In this chapter we will be focusing on the two most common
  examples of bounding volumes: axis-aligned bounding boxes (AABB), and
  spheres. At the end we will briefly discuss another volume that has become
  prevalent in the industry: sphere-swept volumes.

  \section{Axis-aligned Bounding Boxes}
    This is one of the most common bounding volumes used in the graphics
    industry. We define an axis-aligned bounding box (or AABB for short) as
    follows:
    \begin{defn}[Axis-aligned Bounding Box]
      An \emph{axis-aligned bounding box} is a rectangular six-sided box that is
      characterized by having the normals of each face parallel with the axes of
      the given coordinate system.
    \end{defn}

    The property of having the normals remain parallel with the coordinate axes
    is what gives the AABB such a fast intersection test, since we only have to
    compare each individual coordinate value directly.

    The three most common ways to represent an AABB are as follows:
    \begin{enumerate}
      \item \textbf{min-max:} This form stores two points, representing the
        minimum and maximum extents of the box. In code, this would be:
        \begin{lstlisting}[caption=min-max AABB, style=codestyle]
struct AABB
{
  Point min;
  Point max;
};
        \end{lstlisting}

      \item \textbf{min-widths:} stores the minimum corner of the box, along
        with its 3 dimensions (width, height, and length). In code, this is: 
        \begin{lstlisting}[caption=min-widths AABB, style=codestyle]
struct AABB
{
  Point min;
  float d[3];
};
        \end{lstlisting}

      \item \textbf{centre-radius:} stores the centre of the box and the radii
        in each of the 3 axes. In code, this is:
        \begin{lstlisting}[caption=centre-radius AABB, style=codestyle]
struct AABB
{
  Point c;
  float r[3];
};
        \end{lstlisting}
    \end{enumerate}

    \begin{figure}
      \caption{The three representations of an AABB (from left to right):
      min-max, min-widths, and centre-radius}
      \label{fig:aabb}
      \includegraphics[width=\textwidth]{images/aabb_representations}
    \end{figure}

    The three different representations are also shown in Figure \ref{fig:aabb}.

    So which one of these ways is more efficient in terms of storage? At first
    glance, it may seem tempting to say that they are all equivalent. After all,
    we ultimately have to store 6 floats (or doubles) in all three. While this
    may be the case, there are some optimizations that can be done. For example,
    the dimensions of both the centre-radius and the min-widths can be stored
    using less bits than would normally be required. Also, if we set things
    correctly, it is possible to store the dimensions (or radii) as integers,
    which can be more tightly packed than floats. With this in mind, it is clear
    that the worst representation is the min-max, since we are forced to always
    store 6 floats (or doubles) no matter what we do.

    In terms of updating, consider the following:
    \begin{exmp}
      Consider a sequence of $n$ rotations and $m$ translations, each one
      represented by a 3x3 (or 4x4 if we are working in homogeneous coordinates)
      matrices. Suppose that each transformation occurs at each time step of our
      simulation. Which AABB representation requires the least possible number
      of operations?
    \end{exmp}

    For each possible transformation, we incur in a multiplication of a matrix
    by a vector. Since this is constant, then the only way of optimizing the
    number of operations is to reduce it. Looking at the three representations,
    both min-widths and centre-radius require one multiplication, while min-max
    requires two. 

    At this point it would be fair to ask why we would want to use the min-max
    representation of the AABB at all. The reason becomes apparent when looking
    at intersection tests and updates as we will discuss next.

    The intersection test for AABBs is straight-forward: 2 AABBs overlap if they
    overlap on all axes. Regardless of the representation, the algorithm is the
    following:
    \begin{algorithm}
      \caption{AABB intersection test for two boxes $A$ and $B$}
      \label{alg:aabb}
      \begin{algorithmic}
        \State $r \gets 1$
        \For{each coordinate axis}
          \If{$A_{\max} < B_{\min}$ or $A_{\min} > B_{\max}$}
            \State $r \gets 0$
          \EndIf
        \EndFor
        \State \Return $r$
      \end{algorithmic}
    \end{algorithm}

    The optimizations that can be done here mostly depend on the implementation
    that is being used and what functions are available. Based on the algorithm
    presented in \ref{alg:aabb}, we can see that both the min-widths and
    centre-radius representations are less optimal than the min-max, since the
    ranges need to be computed manually before comparison, as opposed to the
    min-max that can compare directly. 

    Now we turn our attention to updating AABBs. Clearly translations preserve
    the alignment of the boxes, but rotations present a particular problem, as
    we will see next.

  \section{Computing and Updating AABBs}
    Recall that AABBs have their face normals parallel to the \emph{given}
    coordinate axes. This means that the AABB is bound to whatever coordinate
    system we used to create it. More specifically, it is bound to the space
    where the box was constructed.
    Generally, this space is the model space for the particular object we are
    bounding. This leads us to an interesting problem: how do we intersect two
    boxes that are defined in different spaces?

    Let us examine this question with the following example:
    \begin{exmp}
      Consider two boxes defined as shown in Figure \ref{}. This figure shows
      the boxes in world space coordinates. We have two possible choices of
      space to transform the boxes to check for intersection: $A$ or $B$. In
      which do the boxes intersect?
    \end{exmp}

    From the diagram it is clear that the boxes are barely touching in world
    space coordinates. Suppose we transform them into the space of $A$. After
    all the translations and rotations take place, we can see that $B$ would
    intersect with $A$. Now let's look at $B$. Notice how $A$ no longer
    intersects?

    This example shows the reason why the choice of space is important for
    performing intersection tests. It also reveals a more subtle problem.
    Whenever we transform from one object space into another, we incur in matrix
    multiplication(s). Since all operations are done in floating point, then
    these transformations introduce additional errors to our computations. More
    importantly, if we transform to a space that is further away from the
    origin, such as $B$, then the values required to perform the operation are
    larger, and so the errors scale. Conversely, if we take a space closer to
    the origin, such as $A$, then the values are smaller and the error
    decreases.

    So the important point here is the following: whenever we choose the space
    to compute intersections, care must be taken to ensure that it introduces
    the least error possible, while keeping in mind that it may give false
    results. With this in mind, lets now look at how to update bounding boxes
    after transformations (specifically rotations) have occurred.

    Since AABBs have to preserve the alignment to the axes (otherwise we loose
    the fast intersection tests), then special care must be taken when they are
    rotated. Whenever we rotate an AABB, it must be updated to preserve its
    alignment to the axes. The most common strategies for this are:

    \begin{itemize}
      \item Use a loose-fitting AABB that always encloses the object.
      \item Compute a tight dynamic reconstruction from the original set.
      \item Computing a tight dynamic reconstruction using hill climbing.
      \item Computing an approximate dynamic reconstruction from the
        rotated AABB.
    \end{itemize}
    Let us examine each one in a bit more detail.

    The first option exploits the fact that spheres are invariant under
    rotations. So the strategy is the following: construct an AABB that bounds
    the bounding sphere of the object. The sphere is centred at the pivot for
    the object, and the radius is set to be the point that is furthest away from
    the pivot. This guarantees that no matter what rotation occurs, the object
    will always remain inside the box and no changes need to be made. There are
    two points of consideration here: first off, the AABB is not tight around
    the object, which can lead to false intersections. The second point is the
    following: since a bounding sphere must be computed in order to determine
    the AABB, why not use the bounding sphere instead? \\
    On the other hand, big advantage of this method is that unless the pivot for
    the object is changed, then the AABB does not need to be updated (save for
    translations).

    The second option involves reconstructing the AABB from the points. This
    means the algorithm shown in \ref{fig:aabb_update}.
    \begin{algorithm}
      \caption{Find the min and max points along an axis $\d$}
      \label{fig:aabb_update}
      \begin{algorithmic}
        \State $i_{\min} \gets -1$
        \State $i_{\max} \gets -1$
        \State $p_{\max} \gets \infty$
        \State $p_{\min} \gets -\infty$
        \For {$i \geq n$}
          \State $p \gets pt[i] \cdot \d$
          \If {$p < p_{\min}$}
            \State $p_{\min} \gets p$
            \State $i_{\min} \gets i$
          \EndIf
          \If {$p > p_{\max}$}
            \State $p_{\max} \gets p$
            \State $i_{\max} \gets i$
          \EndIf
        \EndFor
      \end{algorithmic}
    \end{algorithm}

    Clearly this algorithm runs in $O(n)$. So how can we optimize it?\\
    Well the only option available to us would be to remove as many points as
    possible from the original set. This can be done by noticing that only those
    points that sit on the convex hull of the object contribute to the size of
    the bounding box. That means that we can reduce the runtime of this from
    $O(n)$ to $O(k)$ where $k$ is the size of the convex hull. This has two
    drawbacks: first, note that $k \leq n$, so in the worst case we would still
    have to traverse the entire set. Second, while it is possible to optimize
    the construction of the convex hull by using space partitioning techniques,
    this time is still used at pre-processing. At this stage we have already
    computed the convex hull, so we might as well use it. The only reason why we
    might care for the AABB containing the convex hull of the object is usually
    precision, at which point we should probably consider using the convex hull
    directly.\\
    That being said, intersections against convex hulls are expensive to
    compute, so it could be worthwhile to wrap the convex hull inside an AABB to
    optimize this.


    Another way of optimizing the reconstruction of an AABB requires a way
    to easily obtain the neighbourhood of a specific vertex. Given this, we
    can construct an AABB by maintaining 6 pointers to the most extreme
    points in each of the axes. Whenever we rotate the object, we climb
    along the neighbours of the old vertex until we find a new extremal
    point. This has an obvious drawback: the objects must be convex in order
    for this to work properly (otherwise we would get stuck in local minima
    and would never find the new extremal point). We can further optimize
    this by reducing the number of comparisons we have to perform. For
    example, if we are looking for the maximal point in $+x$, then we only
    need to look at the $x$ coordinate of the vectors. The other obvious
    problem is that hill-climbing requires a robust implementation for
    finding neighbours for any given vertices.

    The last of the four realignment methods is to simply wrap the rotated
    AABB in a new AABB. This gives us a new (approximate) AABB that we can
    use to compute our collision detections. It is important to keep in mind
    that the new AABB \emph{must} be computed with respect to the original
    AABB, otherwise the box will just grow indefinitely.
    The idea is as follows: consider a box $A$ that was transformed by a
    matrix $\mathbf{M}$ resulting in a box $A'$. The three columns (or rows
    depending on the convention) contain the world-coordinate axes of $A'$
    in its local frame. \\
    So what does this all mean? Well suppose that $A$ is given using min-max
    representation and $\mathbf{M}$ is a column matrix. This means that we
    can find the extents of $B$ by simply projecting each of the rotated
    vertices onto the world-coordinate axes. Since minimal and maximal
    extents will be composed by a linear combination of the transformed
    values of $A$, then it is only a matter of finding the new min and max.
    This can be easily done by adding the smaller terms and the largest
    terms (respectively).

  \section{Spheres}
    Spheres are another very common bounding volume. Like AABBs, the
    intersection tests for spheres is very simple to perform. In addition,
    spheres have the property that they are invariant under rotations, which
    means that the only transformation that affects them is translation,
    which is very simple to do. They also have a very compact
    representation: we only need a point and a radius to fully determine a
    sphere. That said, the interesting part of spheres isn't in their
    intersection tests, but rather on how they are computed.

    A first attempt would be to try and find the centre of the mesh (finding
    the geometric mean of all the vertices) and use this as the centre of
    our sphere. The radius would then be the largest distance from this
    point. As attractive as this idea may seem, it actually leads to very
    bad bounding spheres. A better alternative would be to construct an AABB
    and set the centre to be the centre of the bounding box itself. This
    leads to a much better bounding sphere and is as fast as computing the
    AABB and finding the radius.

    An alternative way of computing the bounding sphere is to find an
    approximate bounding sphere (one that doesn't necessarily bound all of
    the points) and then refine it. The idea is the following: find 6 points
    (not necessarily unique) and select the pair that is furthest apart. The
    centre of the sphere becomes the halfway point between these two and the
    radius is the half distance between them. The next step of the process
    is to iteratively loop over all the points on the mesh and check if they
    are already bound by the sphere. If they aren't then the sphere is
    created to encompass the old sphere and the new point. This is done by
    taking the diameter of the sphere to be the distance between the new
    point and the point that sits on the old sphere that is opposite to the
    new point with respect to the old sphere centre.
