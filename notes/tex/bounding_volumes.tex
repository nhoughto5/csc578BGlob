\chapter{Bounding Volumes}
  We begin our discussion of bounding volumes by asking the following
  question: what kind of properties do we want in a bounding volume?
  Ideally, we would want the following:
  \begin{itemize}
    \item Inexpensive intersection tests.
    \item Tight fitting.
    \item Inexpensive to compute.
    \item Easy to transform (rotations are of particular importance).
    \item Use little memory.
  \end{itemize}

  Unfortunately as we will soon see, there have to be trade-offs whenever we
  select a bounding volume. For example: a sphere is trivial to test and
  occupies little memory (it only requires 4 floats). Conversely, a convex
  hull gives us a very tight bound on the object, but requires a lot more
  memory and is more expensive to test for intersections. So the choice of
  bounding volume ultimately boils down to the specific requirements of our
  application. In this chapter we will be focusing on the two most common
  examples of bounding volumes: axis-aligned bounding boxes (AABB), and
  spheres. At the end we will briefly discuss another volume that has become
  prevalent in the industry: sphere-swept volumes.

  \section{Axis-aligned Bounding Boxes}
    This is one of the most common bounding volumes used in the graphics
    industry. We define an axis-aligned bounding box (or AABB for short) as
    follows:
    \begin{defn}[Axis-aligned Bounding Box]
      An \emph{axis-aligned bounding box} is a rectangular six-sided box that is
      characterized by having the normals of each face parallel with the axes of
      the given coordinate system.
    \end{defn}

    The property of having the normals remain parallel with the coordinate axes
    is what gives the AABB such a fast intersection test, since we only have to
    compare each individual coordinate value directly.

    The three most common ways to represent an AABB are as follows:
    \begin{enumerate}
      \item \textbf{min-max:} This form stores two points, representing the
        minimum and maximum extents of the box. In code, this would be:
        \begin{lstlisting}[caption=min-max AABB, style=codestyle]
struct AABB
{
  Point min;
  Point max;
};
        \end{lstlisting}

      \item \textbf{min-widths:} stores the minimum corner of the box, along
        with its 3 dimensions (width, height, and length). In code, this is: 
        \begin{lstlisting}[caption=min-widths AABB, style=codestyle]
struct AABB
{
  Point min;
  float d[3];
};
        \end{lstlisting}

      \item \textbf{centre-radius:} stores the centre of the box and the radii
        in each of the 3 axes. In code, this is:
        \begin{lstlisting}[caption=centre-radius AABB, style=codestyle]
struct AABB
{
  Point c;
  float r[3];
};
        \end{lstlisting}
    \end{enumerate}

    \begin{figure}
      \caption{The three representations of an AABB (from left to right):
      min-max, min-widths, and centre-radius}
      \label{fig:aabb}
      \includegraphics[width=\textwidth]{images/aabb_representations}
    \end{figure}

    The three different representations are also shown in Figure \ref{fig:aabb}.

    So which one of these ways is more efficient in terms of storage? At first
    glance, it may seem tempting to say that they are all equivalent. After all,
    we ultimately have to store 6 floats (or doubles) in all three. While this
    may be the case, there are some optimizations that can be done. For example,
    the dimensions of both the centre-radius and the min-widths can be stored
    using less bits than would normally be required. Also, if we set things
    correctly, it is possible to store the dimensions (or radii) as integers,
    which can be more tightly packed than floats. With this in mind, it is clear
    that the worst representation is the min-max, since we are forced to always
    store 6 floats (or doubles) no matter what we do.

    In terms of updating, consider the following:
    \begin{exmp}
      Consider a sequence of $n$ rotations and $m$ translations, each one
      represented by a 3x3 (or 4x4 if we are working in homogeneous coordinates)
      matrices. Suppose that each transformation occurs at each time step of our
      simulation. Which AABB representation requires the least possible number
      of operations?
    \end{exmp}

    For each possible transformation, we incur in a multiplication of a matrix
    by a vector. Since this is constant, then the only way of optimizing the
    number of operations is to reduce it. Looking at the three representations,
    both min-widths and centre-radius require one multiplication, while min-max
    requires two. 

    At this point it would be fair to ask why we would want to use the min-max
    representation of the AABB at all. The reason becomes apparent when looking
    at intersection tests and updates as we will discuss next.

    The intersection test for AABBs is straight-forward: 2 AABBs overlap if they
    overlap on all axes. Regardless of the representation, the algorithm is the
    following:
    \begin{algorithm}
      \caption{AABB intersection test for two boxes $A$ and $B$}
      \label{alg:aabb}
      \begin{algorithmic}
        \State $r \gets 1$
        \For{each coordinate axis}
          \If{$A_{\max} < B_{\min}$ or $A_{\min} > B_{\max}$}
            \State $r \gets 0$
          \EndIf
        \EndFor
        \State \Return $r$
      \end{algorithmic}
    \end{algorithm}

    The optimizations that can be done here mostly depend on the implementation
    that is being used and what functions are available. Based on the algorithm
    presented in \ref{alg:aabb}, we can see that both the min-widths and
    centre-radius representations are less optimal than the min-max, since the
    ranges need to be computed manually before comparison, as opposed to the
    min-max that can compare directly. 

    Now we turn our attention to updating AABBs. Clearly translations preserve
    the alignment of the boxes, but rotations present a particular problem, as
    we will see next.

  \section{Computing and Updating AABBs}
    Recall that AABBs have their face normals parallel to the \emph{given}
    coordinate axes. This means that the AABB is bound to whatever coordinate
    system we used to create it. More specifically, it is bound to the space
    where the box was constructed.
    Generally, this space is the model space for the particular object we are
    bounding. This leads us to an interesting problem: how do we intersect two
    boxes that are defined in different spaces?

    Let us examine this question with the following example:
    \begin{exmp}
      Consider two boxes defined as shown in Figure \ref{}. This figure shows
      the boxes in world space coordinates. We have two possible choices of
      space to transform the boxes to check for intersection: $A$ or $B$. In
      which do the boxes intersect?
    \end{exmp}

    From the diagram it is clear that the boxes are barely touching in world
    space coordinates. Suppose we transform them into the space of $A$. After
    all the translations and rotations take place, we can see that $B$ would
    intersect with $A$. Now let's look at $B$. Notice how $A$ no longer
    intersects?

    This example shows the reason why the choice of space is important for
    performing intersection tests. It also reveals a more subtle problem.
    Whenever we transform from one object space into another, we incur in matrix
    multiplication(s). Since all operations are done in floating point, then
    these transformations introduce additional errors to our computations. More
    importantly, if we transform to a space that is further away from the
    origin, such as $B$, then the values required to perform the operation are
    larger, and so the errors scale. Conversely, if we take a space closer to
    the origin, such as $A$, then the values are smaller and the error
    decreases.

    So the important point here is the following: whenever we choose the space
    to compute intersections, care must be taken to ensure that it introduces
    the least error possible, while keeping in mind that it may give false
    results. With this in mind, lets now look at how to update bounding boxes
    after transformations (specifically rotations) have occurred.

    Since AABBs have to preserve the alignment to the axes (otherwise we loose
    the fast intersection tests), then special care must be taken when they are
    rotated. Whenever we rotate an AABB, it must be updated to preserve its
    alignment to the axes. The most common strategies for this are:

    \begin{itemize}
      \item Use a loose-fitting AABB that always encloses the object.
      \item Compute a tight dynamic reconstruction from the original set.
      \item Computing a tight dynamic reconstruction using hill climbing.
      \item Computing an approximate dynamic reconstruction from the
        rotated AABB.
    \end{itemize}
    Let us examine each one in a bit more detail.

    The first option exploits the fact that spheres are invariant under
    rotations. So the strategy is the following: construct an AABB that bounds
    the bounding sphere of the object. The sphere is centred at the pivot for
    the object, and the radius is set to be the point that is furthest away from
    the pivot. This guarantees that no matter what rotation occurs, the object
    will always remain inside the box and no changes need to be made. There are
    two points of consideration here: first off, the AABB is not tight around
    the object, which can lead to false intersections. The second point is the
    following: since a bounding sphere must be computed in order to determine
    the AABB, why not use the bounding sphere instead? \\
    On the other hand, big advantage of this method is that unless the pivot for
    the object is changed, then the AABB does not need to be updated (save for
    translations).

    The second option involves reconstructing the AABB from the points. This
    means the algorithm shown in \ref{fig:aabb_update}.
    \begin{algorithm}
      \caption{Find the min and max points along an axis $\d$}
      \label{fig:aabb_update}
      \begin{algorithmic}
        \State $i_{\min} \gets -1$
        \State $i_{\max} \gets -1$
        \State $p_{\max} \gets \infty$
        \State $p_{\min} \gets -\infty$
        \For {$i \geq n$}
          \State $p \gets pt[i] \cdot \d$
          \If {$p < p_{\min}$}
            \State $p_{\min} \gets p$
            \State $i_{\min} \gets i$
          \EndIf
          \If {$p > p_{\max}$}
            \State $p_{\max} \gets p$
            \State $i_{\max} \gets i$
          \EndIf
        \EndFor
      \end{algorithmic}
    \end{algorithm}

    Clearly this algorithm runs in $O(n)$. So how can we optimize it?\\
    Well the only option available to us would be to remove as many points as
    possible from the original set. This can be done by noticing that only those
    points that sit on the convex hull of the object contribute to the size of
    the bounding box. That means that we can reduce the runtime of this from
    $O(n)$ to $O(k)$ where $k$ is the size of the convex hull. This has two
    drawbacks: first, note that $k \leq n$, so in the worst case we would still
    have to traverse the entire set. Second, while it is possible to optimize
    the construction of the convex hull by using space partitioning techniques,
    this time is still used at pre-processing. At this stage we have already
    computed the convex hull, so we might as well use it. The only reason why we
    might care for the AABB containing the convex hull of the object is usually
    precision, at which point we should probably consider using the convex hull
    directly.\\
    That being said, intersections against convex hulls are expensive to
    compute, so it could be worthwhile to wrap the convex hull inside an AABB to
    optimize this.

    The next case is easily shown with the following example.
    \begin{exmp}
      Consider a regular n-gon (like a hexagon for example) that has a vertex
      $v$ with coordinates $(x, 0)$ where $x > 0$. Clearly this point is the
      maximum on the x-axis. Now suppose we rotate the polygon counter-clockwise
      by some angle $\theta$. Which point is more likely to be the new maximum?
    \end{exmp}

    In this example, we can clearly see that we can ignore vertices on the
    opposite side of the polygon (provided $\theta$ isn't too large, as we will
    discuss later). This means that the only vertices that we have to look at
    are those that are neighbours of $v$, which cuts down on our search
    dramatically. This is called hill-climbing.

    This technique requires two things: first off, we need an efficient way of
    obtaining the neighbours of a given vertex. The second requirement is that
    the object must be convex (or we can operate directly on the convex hull of
    the object). Its advantage is clear: it reduces the cost of updating the
    AABB while at the same time providing a very tight fit for the particular
    object. It does however suffer some drawbacks. First, it is perfectly
    possible to encounter a situation where the search through the neighbouring
    vertices does not yield the real maximum (or minimum) in that direction.
    This means that there needs to be some pre-processing done for the object
    before the update is called, or the update function must be robust enough to
    handle these cases.\\
    The second issue comes from the size of the neighbourhood. If the rotation
    is relatively small, then we have to search through a relatively small
    number of vertices. Unfortunately if the object is spinning too quickly,
    then the size of the neighbourhood must increase to accordingly, which can
    lead to lower performance.

    The last of the four realignment methods is to simply wrap the rotated
    AABB in a new AABB. This gives us a new (approximate) AABB that we can use
    in our computations. The first point of consideration is the following:
    \begin{case}
      Consider an object with a bounding box $A$. Now suppose that we apply a
      sequence of rotations $R_1, R_2, \ldots, R_n$. Suppose that for each
      rotation, we wrap the rotated AABB with a new AABB. In other words, $A_1$
      is constructed from $A$, $A_2$ from $A_1$ and so forth. What happens to
      the box? How can we address this problem?
    \end{case}

    This sequence of operations results in the box growing indefinitely. To
    solve this, we simply construct the new AABB based on the \emph{original}
    AABB. Since all the transformations can be easily accumulated into a single
    matrix, we simply take the original box, transform it to whatever step we
    are currently at, and use that transformed box to compute the new one.

    The general idea for the algorithm is the following: consider a box $A$ that
    was transformed by a matrix $\M$ resulting in a box $A'$. First of
    all, recall that a matrix is ultimately a transformation of the basis (the
    coordinate axes) of that vector space (the space where the box was defined).
    That means that encoded inside the matrix $\M$ are the new coordinate axes
    that we are mapping to. The next thing to consider is this: if we rotate the
    minimum and maximum extents of the box, then the new maximum and minimum
    extents will be composed by a linear combination of the originals. This all
    implies that we can simply examine each coordinate individually by looking
    at the appropriate column (or row) on the matrix $\M$ and the transformed
    values of the minimum and maximum of $A$.

    To better understand this, consider the following example:
    \begin{exmp}
      Consider a box $A$ that has maximum $(1, 1, 1)$ and minimum $(-1, -1,
      -1)$. Suppose we apply the following rotation matrix: 
      \[
        \R = 
        \begin{pmatrix}
          1 & 0 & 0 \\
          0 & -1 & 0 \\
          0 & 0 & -1
        \end{pmatrix}
      \]
      Then the new maximum on the x-axis can be computed as follows:
      \begin{align*}
        x'_{\max} &= \max(\R_{0, 0}x_{\min}, \R_{0, 0}x_{\max}) \\
                  &+ \max(\R_{0, 1}x_{\min}, \R_{0, 1}x_{\max}) \\ 
                  &+ \max(\R_{0, 2}x_{\min}, \R_{0, 2}x_{\max}) \\ 
      \end{align*}
    \end{exmp}

    As we can clearly see, we only need to consider the first column of the
    matrix and the x-coordinates of the minimum and maximum to compute the new
    x maximum of the box.

    Next, we turn our attention to bounding spheres. As we will see, the
    interesting part about spheres isn't so much how they are represented or
    updated, but rather how they are created in the first place.

  \section{Spheres}
    Spheres are another very common bounding volume and serve as the foundation
    for another volume found throughout the industry. As we might expect, their
    intersection tests are very straightforward as is their representation. To
    represent a sphere, we just need a centre and radius.
    \begin{lstlisting}[caption=Sphere representation, style=codestyle]
struct Sphere
{
  Point c;
  float r;
};
    \end{lstlisting}

    The intersection test is also pretty simple as is shown in \ref{alg:sphere}.
    \begin{algorithm}
      \caption{Sphere intersection test of two spheres $S_1$ and $S_2$}
      \label{alg:sphere}
      \begin{algorithmic}
        \State $\d \gets \c_1 - \c_2$
        \State $dist \gets \d \cdot \d$
        \State $sum \gets r_1 - r_2$
        \State \Return $dist \leq sum \cdot sum$
      \end{algorithmic}
    \end{algorithm}

    In addition to this, spheres are invariant under rotations, which means that
    their update methods are trivial: we just need to translate the centre as is
    required.\\
    At this stage is worth asking the following: if spheres are so easy to use,
    why aren't they used all the time? Why bother with other volumes? The answer
    is two-fold: first, while spheres are very convenient, they don't always
    provide the best bounding for an object. Second, how do we compute a sphere
    that is tight around the object?

    We will focus on answering the second question for the remainder of the
    chapter. The first question mostly depends on the application and what the
    requirements are, so it will be omitted.\\
    A first attempt would be to try and find the centre of the mesh (finding
    the geometric mean of all the vertices) and use this as the centre of
    our sphere. The radius would then be the largest distance from this
    point. As attractive as this idea may seem, it actually leads to very
    bad bounding spheres in the case where the points are fairly spread out (up
    to twice the needed radius, in fact). So how can we improve this?\\
    Instead of taking the geometric mean, we could construct an AABB around the
    points and then use its centre as the centre of the sphere (it is actually
    the opposite of trying to find an invariant AABB).

    An alternative way of computing the bounding sphere is to find an
    approximate bounding sphere (one that doesn't necessarily bound all of
    the points) and then refine it. The idea is the following: find 6 points
    (not necessarily unique) and select the pair that is furthest apart. The
    centre of the sphere becomes the halfway point between these two and the
    radius is the half distance between them. The next step of the process
    is to iteratively loop over all the points on the mesh and check if they
    are already bound by the sphere. If they aren't then the sphere is
    created to encompass the old sphere and the new point. This is done by
    taking the diameter of the sphere to be the distance between the new
    point and the point that sits on the old sphere that is opposite to the
    new point with respect to the old sphere centre.

    The idea of this algorithm will be the theme for the rest of the chapter.
    Essentially we start with a guess (how good this guess is depends on the
    method) and then we iteratively refine it until we get a sphere that bounds
    the entire object.
